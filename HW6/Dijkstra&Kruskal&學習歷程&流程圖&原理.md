## Dijkstra流程圖
![](https://github.com/ykz0608/DSA/blob/master/image/Dijkstra.svg)
* 初始狀態：S是已計算出最短路徑的頂點集合
* U是未計算除最短路徑的頂點的集合 
1. 將頂點D加入到S中。
    * 此時，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。     
    * 注:C(3)表示C到起點D的距離是3。

2. 將頂點C加入到S中。
    * 上一步操作之後，U中頂點C到起點D的距離最短；
    * 將C加入到S中，同時更新U中頂點的距離。以頂點F爲例，之前F到D的距離爲∞；但是將C加入到S之後，F到D的距離爲9=(F,C)+(C,D)。
    * 此時，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。

3. 將頂點E加入到S中。
    * 上一步操作之後，U中頂點E到起點D的距離最短；
    * 將E加入到S中，同時更新U中頂點的距離。還是以頂點F爲例，之前F到D的距離爲9；但是將E加入到S之後，F到D的距離爲6=(F,E)+(E,D)。
    * 此時，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。

4. 將頂點F加入到S中。
    * 此時，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。

5. 將頂點G加入到S中。
    * 此時，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。

6. 將頂點B加入到S中。
    * 此時，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。

7. 將頂點A加入到S中。
    * 此時，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。

* 此時，起點D到各個頂點的最短距離就計算出來了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。

## Kruskal流程圖
![](https://github.com/ykz0608/DSA/blob/master/image/Kruskal.svg)
1. 將邊<E,F>加入R中。
    * 邊<E,F>的權值最小，因此將它加入到最小生成樹結果R中。
2. 將邊<C,D>加入R中。
    * 上一步操作之後，邊<C,D>的權值最小
    * 將它加入到最小生成樹結果R中。
3. 將邊<D,E>加入R中。
    * 上一步操作之後，邊<D,E>的權值最小
    * 將它加入到最小生成樹結果R中。
4. 將邊<B,F>加入R中。
    * 上一步操作之後，邊<C,E>的權值最小
    * 但<C,E>會和已有的邊構成迴路
    * 因此，跳過邊<C,E>。同理，跳過邊<C,F>。將邊<B,F>加入到最小生成樹結果R中。
5. 將邊<E,G>加入R中。
    * 上一步操作之後，邊<E,G>的權值最小
    * 將它加入到最小生成樹結果R中。
6. 將邊<A,B>加入R中。
    * 上一步操作之後，邊<F,G>的權值最小，
    * 但<F,G>會和已有的邊構成迴路；因此，跳過邊<F,G>。
    * 跳過邊<B,C>。將邊<A,B>加入到最小生成樹結果R中。

* 此時，最小生成樹構造完成！它包括的邊依次是：<E,F> <C,D> <D,E> <B,F> <E,G> <A,B>。
